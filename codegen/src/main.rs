#![doc = include_str!("../README.md")]
use std::{
    fmt::Debug,
    fs,
    path::{Path, PathBuf},
    str,
};

use proc_macro2::{Ident, Span, TokenStream};
use tests::build_tests;
use toml::{Table, Value, toml};

use clap::Parser;

use v_escape_codegen_base::generate as generate_base;
mod tests;

fn ident(s: &str) -> Ident {
    Ident::new(s, Span::call_site())
}

/// V_escape codegen - A tool for generating escape functions
#[derive(Parser, Debug)]
#[clap(
    author,
    version,
    about = "Generate escape functions from template files",
    long_about = "A tool for generating SIMD-optimized escape functions from template files. 
    
Creates a new crate with escape_fmt and escape_string functions based on character mappings defined in src/_lib.rs.

Example usage:
  mkdir my_escape
  cd my_escape
  cargo init --lib
  cat <<EOF > src/_lib.rs
  new!(
      '&' -> \"&amp;\",
      '<' -> \"&lt;\",
      '>' -> \"&gt;\",
      '\"' -> \"&quot;\",
      '\\'' -> \"&#x27;\"
  );
  EOF
  v_escape-codegen -i .",
    after_help = "For more information, see: https://github.com/zzau13/v_escape"
)]
struct Args {
    /// Input directory containing the crate to generate
    #[clap(short, long, default_value = "./", value_name = "DIR")]
    pub input_dir: PathBuf,
}

fn read_cargo(p: &Path) -> anyhow::Result<(Table, String)> {
    let mut cargo = fs::read_to_string(p)
        .map_err(|e| anyhow::anyhow!("Failed to read Cargo.toml: {}", e))?
        .parse::<Table>()
        .map_err(|e| anyhow::anyhow!("Failed to parse Cargo.toml: {}", e))?;

    cargo
        .get_mut("package")
        .ok_or_else(|| anyhow::anyhow!("Expected a package section in Cargo.toml"))?
        .as_table_mut()
        .ok_or_else(|| anyhow::anyhow!("Expected a table for package"))?
        .insert(
            "metadata".to_string(),
            toml! {
                [docs.rs]
                all-features = true
            }
            .into(),
        );

    cargo.insert(
        "features".into(),
        toml! {
            default = ["std", "string", "fmt", "bytes"]
            std = ["v_escape-base/std", "alloc"]
            alloc = ["v_escape-base/alloc"]
            string = ["v_escape-base/string"]
            fmt = ["v_escape-base/fmt"]
            bytes = ["v_escape-base/bytes"]
        }
        .into(),
    );

    cargo
        .entry("dependencies")
        .or_insert_with(|| Value::Table(Table::new()))
        .as_table_mut()
        .ok_or_else(|| anyhow::anyhow!("Expected a table for dependencies"))?
        .insert("v_escape-base".into(), toml! { workspace = true }.into());

    let package_name = cargo
        .get("package")
        .ok_or_else(|| anyhow::anyhow!("Expected a package section in Cargo.toml"))?
        .as_table()
        .ok_or_else(|| anyhow::anyhow!("Expected a table for package"))?
        .get("name")
        .ok_or_else(|| anyhow::anyhow!("Expected a name in package section"))?
        .as_str()
        .ok_or_else(|| anyhow::anyhow!("Expected a name as str"))?
        .to_string();

    Ok((cargo, package_name))
}

fn generate(dir: &Path) -> anyhow::Result<()> {
    let head = concat!(
        "//! autogenerated by v_escape_codegen@",
        env!("CARGO_PKG_VERSION"),
        "\n"
    );

    if !dir.is_dir() {
        anyhow::bail!("input_dir should be a directory");
    }

    // Modify Cargo.toml
    // TODO: should use a pretty toml
    let cargo_path = dir.join("Cargo.toml");
    let (cargo, name) = read_cargo(&cargo_path)?;

    // Check directories
    let src = dir.join("src");
    let test = dir.join("tests");
    if !test.exists() {
        fs::create_dir(&test)?;
    }
    // Read template
    let template = src.join("_lib.rs");
    let template_src = fs::read_to_string(&template)?;

    // Generate code
    let (code, (escapes, escaped)) = generate_base(
        template_src
            .parse::<TokenStream>()
            .map_err(|e| anyhow::anyhow!("Failed to parse template source: {}", e))?,
        "v_escape_base",
    )?;

    // Prettify code
    let mut code_pretty = prettyplease::unparse(
        &syn::parse2(code)
            .map_err(|e| anyhow::anyhow!("Failed to parse code to TokenStream: {}", e))?,
    );
    code_pretty.insert_str(0, head);
    // Generate tests
    let code_test = build_tests(&ident(&name), &escapes, &escaped);
    let mut code_test_pretty = prettyplease::unparse(
        &syn::parse2(code_test)
            .map_err(|e| anyhow::anyhow!("Failed to parse code to TokenStream: {}", e))?,
    );
    code_test_pretty.insert_str(0, head);

    // Write files
    fs::write(&cargo_path, toml::to_string_pretty(&cargo)?)?;
    fs::write(src.join("lib.rs"), &code_pretty)?;
    fs::write(test.join("lib.rs"), &code_test_pretty)?;

    Ok(())
}

fn main() -> anyhow::Result<()> {
    generate(&Args::parse().input_dir)
}
